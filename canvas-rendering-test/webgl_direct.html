<!DOCTYPE html>
<html>
	<head>
		<style type="text/css">
			body {
				font-family: Arial
			}
		</style>
	</head>

	<body>
		<!--
		<h2> Direct WebGL</h2>
		-->
		<div id="container"> </div>
		
		<div> Test div </div>
		<p> Test paragraph </p>
	</body>


	<script type="text/javascript" src="http://mrdoob.github.com/three.js/build/Three.js"></script>
	<script type="text/javascript" src="data.js"></script>
	<script type="text/javascript" src="line-transformer.js"></script>
	
	<script type="text/javascript" src="gl-matrix-b20120514-min.js"></script>
	
	<script id="fragment-shader" type="null">
		precision mediump float;
		
		void main(void) {
			gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
		}
	</script>
	
	<script id="vertex-shader" type="null">
		attribute vec2 vertex;
		const float factor = 10.0;
		
		uniform mat3 projectionMatrix;
		uniform mat3 modelViewMatrix;
		
		void main(void) {
			// vertex.x = 1.33;
			gl_Position = vec4(vertex.x / 1.33 / factor + 0.2, 0.2 + vertex.y / factor, 0.0, 1.0);
		}
		
	</script>
	
	<script>
		var WIDTH = 800;
		var HEIGHT = 600;
		
		var container = document.getElementById("container");
		container.style.position = "relative";
		container.style.width = WIDTH + "px";
		container.style.height = HEIGHT + "px";
		
		var canvas2d = document.createElement("canvas");
		canvas2d.width = WIDTH;
		canvas2d.height = HEIGHT;
		canvas2d.style.position = "absolute";
		canvas2d.style.zIndex = 2;
		container.appendChild(canvas2d);
		
		var canvas = document.createElement("canvas");
		canvas.width = WIDTH;
		canvas.height = HEIGHT;
		canvas.style.position = "absolute";
		canvas.style.zIndex = 1;
		container.appendChild(canvas);

		var gl = canvas.getContext("experimental-webgl")
			|| canvas.getContext("webkit-3d")
			|| canvas.getContext("moz-webgl")
			|| canvas.getContext("webgl");
		
		if (gl == null) {
			alert("webGL not found");
		}
		
		var testNetwork = new Network(40, 400);
		var nodes = testNetwork.nodes;
		var edges = testNetwork.edges;

		// var lineTransformer = new LineTransformer();
		
		var shaderElement, shaderText;
		
		var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
		
		shaderElement = document.getElementById("fragment-shader");
		shaderText = shaderElement.innerHTML;
		
		gl.shaderSource(fragmentShader, shaderText);
		gl.compileShader(fragmentShader);
		
		
		var vertexShader = gl.createShader(gl.VERTEX_SHADER);
		
		shaderElement = document.getElementById("vertex-shader");
		shaderText = shaderElement.innerHTML;
		
		gl.shaderSource(vertexShader, shaderText);
		gl.compileShader(vertexShader);
		
		/*
		if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
			alert("fragment shader not compiled");
		} else {
			alert("fragment shader compiled");
		}
		
		if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
			alert("vertex shader not compiled");
		} else {
			alert("vertex shader compiled");
		}
		*/
		
		var shaderProgram = gl.createProgram();
		gl.attachShader(shaderProgram, vertexShader);
		gl.attachShader(shaderProgram, fragmentShader);
		gl.linkProgram(shaderProgram);
		
		if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
			alert("could not initialize shaders");
		}
		
		gl.useProgram(shaderProgram);
		shaderProgram.vertexAttribute = gl.getAttribLocation(shaderProgram, "vertex");
		shaderProgram.projectionMatrix = gl.getUniformLocation(shaderProgram, "projectionMatrix");
		shaderProgram.modelViewMatrix = gl.getUniformLocation(shaderProgram, "modelViewMatrix");
		
		gl.enableVertexAttribArray(shaderProgram.vertexAttribute);
		
		
		var triangleVertexBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexBuffer);
		
		var projectionMatrix = new Float32Array([
			1.0 / WIDTH, 0, 0,
			0, 1.0 / HEIGHT, 0,
			0, 0, 1
		]);
		
		var modelViewMatrix = new Float32Array([
			1, 0, 0,
			0, 1, 0,
			0, 0, 1
		]);
		
		var vertices = [0.0, 0.0];
		var segments = 12;
		var increment = Math.PI * 2 / segments;
		
		for (var angle = -increment; angle < Math.PI * 2; angle += increment) {
			vertices.push(Math.cos(angle), Math.sin(angle));
		}
		
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
		
		gl.vertexAttribPointer(shaderProgram.vertexAttribute, 2, gl.FLOAT, false, 0, 0);
		gl.drawArrays(gl.TRIANGLE_FAN, 0, segments + 2);
		
		
		
		// Spread nodes
		for (var i = 0; i < nodes.length; i++) {
			nodes[i].x = Math.random() * WIDTH;
			nodes[i].y = Math.random() * HEIGHT;
		}

		var startNode, endNode;
		for (var i = 0; i < edges.length; i++) {
			
			startNode = nodes[edges[i].start];
			endNode = nodes[edges[i].end];
		}

		for (var i = 0; i < nodes.length; i++) {
		}

		// Draw text
		// updateText();
		
		function updateText() {
			var context2d = canvas2d.getContext("2d");
			context2d.clearRect(0, 0, WIDTH, HEIGHT);
			context2d.font = "normal 14px Verdana";
			context2d.textAlign = "center";
			context2d.textBaseline = "middle";
		
			for (var i = 0; i < nodes.length; i++) {
				context2d.fillText(nodes[i].name, nodes[i].x, 600 - nodes[i].y - 15);
			}
		}
		
		container.addEventListener("mousemove", onDocumentMouseMove, false);
		container.addEventListener("mousedown", onDocumentMouseDown, false);
		container.addEventListener("mouseup", onDocumentMouseUp, false);
		
		function onDocumentMouseMove(event) {
			event.preventDefault();
			
			var mouseX = event.clientX - container.offsetLeft;
			var mouseY = HEIGHT - (event.clientY - container.offsetTop);
			
		}
		
		function onDocumentMouseDown(event) {
			event.preventDefault();
			
			var mouseX = event.clientX - container.offsetLeft;
			var mouseY = HEIGHT - (event.clientY - container.offsetTop);
			
			alert("mouse down: " + mouseX + ", " + mouseY);
		}
						
		function onDocumentMouseUp(event) {
			event.preventDefault();
		}
		
	</script>
</html>
